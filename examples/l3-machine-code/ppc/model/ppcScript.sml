(* ppcScript.sml - generated by L3 - Mon Jun 27 13:52:14 2022 *)
open HolKernel boolLib bossLib Import

val () = Import.start "ppc"

val _ = Construct
  [("instruction",
    [("Add",[PTy(FTy 5,PTy(FTy 5,FTy 5))]),("Undefined",[F32])])]
;
val _ = Construct [("MachineCode",[("Inst",[F32])])]
;
val _ = Construct
  [("exception",
    [("ASSERT",[sTy]),("NoException",[]),("UNDEFINED",[PTy(sTy,F32)]),
     ("UNPREDICTABLE",[sTy])])]
;
val _ = Record
  ("ppc_state",
   [("CTR",F32),("LR",F32),("MEM",ATy(F32,F8)),("PC",F32),
    ("REG",ATy(FTy 5,F32)),("exception",CTy"exception")])
;
val qTy = CTy "ppc_state";
fun qVar v = Term.mk_var (v, ParseDatatype.pretypeToType qTy);
val raise'exception_def = Def
  ("raise'exception",Var("e",CTy"exception"),
   Close
     (qVar"state",
      TP[LX(VTy"a"),
         ITE(EQ(Dest("exception",CTy"exception",qVar"state"),
                Const("NoException",CTy"exception")),
             Rupd("exception",TP[qVar"state",Var("e",CTy"exception")]),
             qVar"state")]))
;
val R_def = Def
  ("R",Var("n",FTy 5),
   Close
     (qVar"state",
      Apply(Dest("REG",ATy(FTy 5,F32),qVar"state"),Var("n",FTy 5))))
;
val write'R_def = Def
  ("write'R",TP[Var("value",F32),Var("n",FTy 5)],
   Close
     (qVar"state",
      Rupd
        ("REG",
         TP[qVar"state",
            Fupd
              (Dest("REG",ATy(FTy 5,F32),qVar"state"),Var("n",FTy 5),
               Var("value",F32))])))
;
val mem1_def = Def
  ("mem1",Var("address",F32),
   Close
     (qVar"state",
      Mop(Cast vTy,
          Apply(Dest("MEM",ATy(F32,F8),qVar"state"),Var("address",F32)))))
;
val mem_def = Def
  ("mem",TP[Var("address",F32),nVar"size"],
   Close
     (qVar"state",
      CS(nVar"size",
         [(LN 1,
           TP[EX(Apply
                   (Call
                      ("mem1",ATy(qTy,vTy),
                       Bop(Add,Var("address",F32),LW(0,32))),qVar"state"),
                 LN 7,LN 0,vTy),qVar"state"]),
          (LN 2,
           TP[EX(CC[Apply
                      (Call
                         ("mem1",ATy(qTy,vTy),
                          Bop(Add,Var("address",F32),LW(1,32))),
                       qVar"state"),
                    Apply
                      (Call
                         ("mem1",ATy(qTy,vTy),
                          Bop(Add,Var("address",F32),LW(0,32))),
                       qVar"state")],LN 15,LN 0,vTy),qVar"state"]),
          (LN 4,
           TP[EX(CC[Apply
                      (Call
                         ("mem1",ATy(qTy,vTy),
                          Bop(Add,Var("address",F32),LW(3,32))),
                       qVar"state"),
                    Apply
                      (Call
                         ("mem1",ATy(qTy,vTy),
                          Bop(Add,Var("address",F32),LW(2,32))),
                       qVar"state"),
                    Apply
                      (Call
                         ("mem1",ATy(qTy,vTy),
                          Bop(Add,Var("address",F32),LW(1,32))),
                       qVar"state"),
                    Apply
                      (Call
                         ("mem1",ATy(qTy,vTy),
                          Bop(Add,Var("address",F32),LW(0,32))),
                       qVar"state")],LN 31,LN 0,vTy),qVar"state"]),
          (AVar nTy,
           Apply
             (Call
                ("raise'exception",ATy(qTy,PTy(vTy,qTy)),
                 Call
                   ("ASSERT",CTy"exception",LS"mem: size not in {1, 2, 4}")),
              qVar"state"))])))
;
val write'mem_def = Def
  ("write'mem",TP[vVar"value",Var("address",F32),nVar"size"],
   Close
     (qVar"state",
      CS(nVar"size",
         [(LN 1,
           Rupd
             ("MEM",
              TP[qVar"state",
                 Fupd
                   (Dest("MEM",ATy(F32,F8),qVar"state"),
                    Bop(Add,Var("address",F32),LW(0,32)),
                    Mop(Cast F8,EX(vVar"value",LN 7,LN 0,vTy)))])),
          (LN 2,
           Let(qVar"s",
               Rupd
                 ("MEM",
                  TP[qVar"state",
                     Fupd
                       (Dest("MEM",ATy(F32,F8),qVar"state"),
                        Bop(Add,Var("address",F32),LW(0,32)),
                        Mop(Cast F8,EX(vVar"value",LN 7,LN 0,vTy)))]),
               Rupd
                 ("MEM",
                  TP[qVar"s",
                     Fupd
                       (Dest("MEM",ATy(F32,F8),qVar"s"),
                        Bop(Add,Var("address",F32),LW(1,32)),
                        Mop(Cast F8,EX(vVar"value",LN 15,LN 8,vTy)))]))),
          (LN 4,
           Let(qVar"s",
               Rupd
                 ("MEM",
                  TP[qVar"state",
                     Fupd
                       (Dest("MEM",ATy(F32,F8),qVar"state"),
                        Bop(Add,Var("address",F32),LW(0,32)),
                        Mop(Cast F8,EX(vVar"value",LN 7,LN 0,vTy)))]),
               Let(qVar"s",
                   Rupd
                     ("MEM",
                      TP[qVar"s",
                         Fupd
                           (Dest("MEM",ATy(F32,F8),qVar"s"),
                            Bop(Add,Var("address",F32),LW(1,32)),
                            Mop(Cast F8,EX(vVar"value",LN 15,LN 8,vTy)))]),
                   Let(qVar"s",
                       Rupd
                         ("MEM",
                          TP[qVar"s",
                             Fupd
                               (Dest("MEM",ATy(F32,F8),qVar"s"),
                                Bop(Add,Var("address",F32),LW(2,32)),
                                Mop(Cast F8,
                                    EX(vVar"value",LN 23,LN 16,vTy)))]),
                       Rupd
                         ("MEM",
                          TP[qVar"s",
                             Fupd
                               (Dest("MEM",ATy(F32,F8),qVar"s"),
                                Bop(Add,Var("address",F32),LW(3,32)),
                                Mop(Cast F8,
                                    EX(vVar"value",LN 31,LN 24,vTy)))]))))),
          (AVar nTy,
           Mop(Snd,
               Apply
                 (Call
                    ("raise'exception",ATy(qTy,PTy(uTy,qTy)),
                     Call
                       ("ASSERT",CTy"exception",
                        LS"mem: size not in {1, 2, 4}")),qVar"state")))])))
;
val Align_def = Def
  ("Align",TP[Var("w",BTy"N"),nVar"n"],
   Mop(Cast(BTy"N"),
       Bop(Mul,nVar"n",Bop(Div,Mop(Cast nTy,Var("w",BTy"N")),nVar"n"))))
;
val Aligned_def = Def
  ("Aligned",TP[Var("w",BTy"N"),nVar"n"],
   EQ(Var("w",BTy"N"),Call("Align",BTy"N",TP[Var("w",BTy"N"),nVar"n"])))
;
val MemA_def = Def
  ("MemA",TP[Var("address",F32),nVar"size"],
   Close
     (qVar"state",
      ITE(Mop(Not,Call("Aligned",bTy,TP[Var("address",F32),nVar"size"])),
          Apply
            (Call
               ("raise'exception",ATy(qTy,PTy(BTy"N",qTy)),
                Call("ASSERT",CTy"exception",LS"MemA: unaligned address")),
             qVar"state"),
          Let(TP[vVar"v",qVar"s"],
              Apply
                (Call
                   ("mem",ATy(qTy,PTy(vTy,qTy)),
                    TP[Var("address",F32),nVar"size"]),qVar"state"),
              TP[Mop(Cast(BTy"N"),vVar"v"),qVar"s"]))))
;
val write'MemA_def = Def
  ("write'MemA",TP[Var("value",BTy"N"),Var("address",F32),nVar"size"],
   Close
     (qVar"state",
      ITE(Mop(Not,Call("Aligned",bTy,TP[Var("address",F32),nVar"size"])),
          Mop(Snd,
              Apply
                (Call
                   ("raise'exception",ATy(qTy,PTy(uTy,qTy)),
                    Call
                      ("ASSERT",CTy"exception",LS"MemA: unaligned address")),
                 qVar"state")),
          Apply
            (Call
               ("write'mem",ATy(qTy,qTy),
                TP[Mop(Cast vTy,Var("value",BTy"N")),Var("address",F32),
                   nVar"size"]),qVar"state"))))
;
val MemU_def = Def
  ("MemU",TP[Var("address",F32),nVar"size"],
   Close
     (qVar"state",
      Apply
        (Call
           ("MemA",ATy(qTy,PTy(BTy"N",qTy)),
            TP[Var("address",F32),nVar"size"]),qVar"state")))
;
val write'MemU_def = Def
  ("write'MemU",TP[Var("value",BTy"N"),Var("address",F32),nVar"size"],
   Close
     (qVar"state",
      Apply
        (Call
           ("write'MemA",ATy(qTy,qTy),
            TP[Var("value",BTy"N"),Var("address",F32),nVar"size"]),
         qVar"state")))
;
val BranchTo_def = Def
  ("BranchTo",Var("address",F32),
   Close(qVar"state",Rupd("PC",TP[qVar"state",Var("address",F32)])))
;
val IncPC_def = Def
  ("IncPC",AVar uTy,
   Close
     (qVar"state",
      Apply
        (Call
           ("BranchTo",ATy(qTy,qTy),
            Bop(Add,Dest("PC",F32,qVar"state"),LW(4,32))),qVar"state")))
;
val dfn'Add_def = Def
  ("dfn'Add",TP[Var("d",FTy 5),Var("a",FTy 5),Var("b",FTy 5)],
   Close
     (qVar"state",
      Apply
        (Call("IncPC",ATy(qTy,qTy),LU),
         Apply
           (Call
              ("write'R",ATy(qTy,qTy),
               TP[Bop(Add,
                      Apply
                        (Call("R",ATy(qTy,F32),Var("a",FTy 5)),qVar"state"),
                      Apply
                        (Call("R",ATy(qTy,F32),Var("b",FTy 5)),qVar"state")),
                  Var("d",FTy 5)]),qVar"state"))))
;
val dfn'Undefined_def = Def
  ("dfn'Undefined",Var("imm32",F32),
   Close
     (qVar"state",
      Mop(Snd,
          Apply
            (Call
               ("raise'exception",ATy(qTy,PTy(uTy,qTy)),
                Call
                  ("UNDEFINED",CTy"exception",
                   TP[LS"Unrecognised instruction",Var("imm32",F32)])),
             qVar"state"))))
;
val Run_def = Def
  ("Run",Var("v0",CTy"instruction"),
   Close
     (qVar"state",
      CS(Var("v0",CTy"instruction"),
         [(Call
             ("Add",CTy"instruction",Var("v1",PTy(FTy 5,PTy(FTy 5,FTy 5)))),
           Apply
             (Call
                ("dfn'Add",ATy(qTy,qTy),
                 Var("v1",PTy(FTy 5,PTy(FTy 5,FTy 5)))),qVar"state")),
          (Call("Undefined",CTy"instruction",Var("v2",F32)),
           Apply
             (Call("dfn'Undefined",ATy(qTy,qTy),Var("v2",F32)),qVar"state"))])))
;
val Fetch_def = Def
  ("Fetch",qVar"state",
   Let(TP[Var("v",F32),qVar"s"],
       Apply
         (Call
            ("MemA",ATy(qTy,PTy(F32,qTy)),
             TP[Dest("PC",F32,qVar"state"),LN 4]),qVar"state"),
       TP[Call("Inst",CTy"MachineCode",Var("v",F32)),qVar"s"]))
;
val DecodeInst_def = Def
  ("DecodeInst",Var("w",F32),
   Let(TP[bVar"b'31",bVar"b'30",bVar"b'29",bVar"b'28",bVar"b'27",
          bVar"b'26",bVar"b'25",bVar"b'24",bVar"b'23",bVar"b'22",
          bVar"b'21",bVar"b'20",bVar"b'19",bVar"b'18",bVar"b'17",
          bVar"b'16",bVar"b'15",bVar"b'14",bVar"b'13",bVar"b'12",
          bVar"b'11",bVar"b'10",bVar"b'9",bVar"b'8",bVar"b'7",bVar"b'6",
          bVar"b'5",bVar"b'4",bVar"b'3",bVar"b'2",bVar"b'1",bVar"b'0"],
       BL(32,Var("w",F32)),
       ITE(Bop(And,Mop(Not,bVar"b'31"),
               Bop(And,bVar"b'30",
                   Bop(And,bVar"b'29",
                       Bop(And,bVar"b'28",
                           Bop(And,bVar"b'27",
                               Bop(And,bVar"b'26",
                                   Bop(And,Mop(Not,bVar"b'10"),
                                       Bop(And,bVar"b'9",
                                           Bop(And,Mop(Not,bVar"b'8"),
                                               Bop(And,Mop(Not,bVar"b'7"),
                                                   Bop(And,
                                                       Mop(Not,bVar"b'6"),
                                                       Bop(And,
                                                           Mop(Not,
                                                               bVar"b'5"),
                                                           Bop(And,
                                                               bVar"b'4",
                                                               Bop(And,
                                                                   Mop(Not,
                                                                       bVar"b'3"),
                                                                   Bop(And,
                                                                       bVar"b'2",
                                                                       Bop(And,
                                                                           Mop(Not,
                                                                               bVar"b'1"),
                                                                           Mop(Not,
                                                                               bVar"b'0"))))))))))))))))),
           Call
             ("Add",CTy"instruction",
              TP[Mop(Cast(FTy 5),
                     LL[bVar"b'25",bVar"b'24",bVar"b'23",bVar"b'22",
                        bVar"b'21"]),
                 Mop(Cast(FTy 5),
                     LL[bVar"b'20",bVar"b'19",bVar"b'18",bVar"b'17",
                        bVar"b'16"]),
                 Mop(Cast(FTy 5),
                     LL[bVar"b'15",bVar"b'14",bVar"b'13",bVar"b'12",
                        bVar"b'11"])]),
           Call("Undefined",CTy"instruction",LW(0,32)))))
;
val Decode_def = Def
  ("Decode",Var("mc",CTy"MachineCode"),
   CS(Var("mc",CTy"MachineCode"),
      [(Call("Inst",CTy"MachineCode",Var("w",F32)),
        Call("DecodeInst",CTy"instruction",Var("w",F32)))]))
;
val Next_def = Def
  ("Next",qVar"state",
   Let(TP[Var("v",CTy"MachineCode"),qVar"s"],
       Apply
         (Const("Fetch",ATy(qTy,PTy(CTy"MachineCode",qTy))),qVar"state"),
       Apply
         (Call
            ("Run",ATy(qTy,qTy),
             Call("Decode",CTy"instruction",Var("v",CTy"MachineCode"))),
          qVar"s")))

val () = Import.finish 1